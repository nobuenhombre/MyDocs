# Общая Архитектура Параллелизма

(перевод статьи - https://gist.github.com/CMCDragonkai/67b82523fe4cc456f06e#file-php_shared_nothing_concurrency_architecture-md)

Хотя PHP теперь имеет ряд функций, которые позволяют контролировать параллелизм, он был разработан с философией архитектуры shared-nothing.

Все, что должно было быть общим, должно было быть перенесено в согласованную надежную базу данных или сетевую файловую систему. Allstate внутри процесса PHP должен был быть недолгим и существовать только в пределах одного жизненного цикла PHP, который также является жизненным циклом запроса и ответа HTTP.

Это позволяет приложению PHP быть линейно масштабируемым. Теоретически вы можете просто раскрутить столько обработчиков PHP-процессов, сколько вам нужно. Единственным узким местом является уровень базы данных или файловой системы.

Понимание этой философии очень важно при решении любых проблем параллелизма в PHP-приложении с shared-nothing. Все виды решений для обеспечения согласованности и синхронизации должны предоставляться базовым хранилищем данных.

Однажды я допустил ошибку при написании библиотеки PHP. Я случайно сделал любое PHP-приложение, использующее эту библиотеку, обладающим недетерминированной операционной семантикой из-за проблемы согласованности кэша.

В принципе, вместо того, чтобы полагаться на базу данных для обработки всего общего состояния. Состояние из базы данных запрашивалось в начале каждого жизненного цикла PHP, затем оно сохранялось в памяти, что позволяло разработчику думать, что они могут мутировать эти данные и безопасно сохранять данные обратно в базу данных. Это было бы верно только в том случае, если бы не было параллельных запросов, затрагивающих одни и те же данные. В этом случае возможна потеря данных, так как мутации данных зависят от данных, запрашиваемых в начале жизненного цикла, но к моменту записи этих данных в базу данных эти данные уже устарели. Это означало, что новые обновленные данные обновлялись на основе более не соответствующих допущений.

Вот более простой пример. Предположим, у меня есть суммарный счетчик, который отслеживает количество просмотров страниц, и я хочу увеличить каждый запрос. При первом запросе я запросил данные как 1000, добавил 1, чтобы получить 1001, и написал это в базу данных. Теперь предположим, что 2 запроса происходят одновременно, каждый из которых запрашивает данные, чтобы получить 1001, каждый из них увеличивает оба до 1002, и каждый отправляет 1002 в базу данных. Это, очевидно, неверно, и правильно будет 1003.

Выше именно то, что произошло при использовании этой библиотеки. Я в основном ввел проблему согласованности кэша в то, что должно быть общим приложением PHP.

В PHP есть много способов решить эту проблему согласованности кэша. Самый простой способ-просто удалить это вычисление с отслеживанием состояния и переместить его в базу данных. Вместо того, чтобы мутировать на основе состояния, которое существует внутри процесса PHP, мутировать, используя только API базы данных, например, с помощью транзакции, блокировки или атомарного обновления SQL запроса:

```
UPDATE table SET x = x + 1 WHERE id = y;
```

Использование транзакционных блокировок см. В разделе:

- http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock
- https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html
- http://www.postgresql.org/docs/9.4/static/sql-select.html#SQL-FOR-UPDATE-SHARE

Будьте осторожны при использовании любых" активных записей " или других инструментов абстракции базы данных, так как они могут быть слишком негерметичными и мешать вам в полной мере использовать методы управления параллелизмом вашей базы данных.

Если вы все еще хотите сохранить это вычисление с отслеживанием состояния внутри вашего PHP-процесса, вам нужно будет реализовать модель согласованности кэша, которая позволит вашим процессам координировать свои мутации, чтобы они были согласованными.

Посмотрите в Cache-coherency для получения дополнительной информации об этом.

## Примечание О Сессиях

Из-за общей архитектуры shared-nothing, если ваше PHP-приложение управляет сессиями, то вам лучше убедиться, что каждый запрос для определенной пользовательской сессии идет в ту же среду выполнения PHP. В противном случае вы все еще сталкиваетесь с теми же проблемами согласованности кэша, но для сессий. Большинство веб-серверов поддерживают эту возможность закрепления конечной точки.

В противном случае нужно каким-то образом разделить сессии в конечных точках.

